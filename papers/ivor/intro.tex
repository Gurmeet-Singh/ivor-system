\section{Introduction}

%\Ivor{} is a tactic-based theorem proving engine with a Haskell
%API. Unlike other systems such as \Coq{}~\cite{coq-manual} and
%Agda~\cite{agda}, the tactic engine is primarily intended to be used
%by programs, rather than a human operator. 

Type theory based theorem provers such as \Coq{}~\cite{coq-manual} and
\Agda{}~\cite{agda} have been used as tools for verification of programs
(e.g.~\cite{leroy-compiler,why-tool,mckinna-expr}), extraction of
correct programs from proofs (e.g.~\cite{extraction-coq,large-extraction})
and formal proofs of mathematical properties
(e.g.~\cite{fta,four-colour}).  However, these tools are designed with a
human operator in mind; the interface is textual which makes it
difficult for an external program to interact with them. 
In contrast, the \Ivor{} library is designed to provide an
implementation of dependent type theory (i.e. dependently typed
$\lambda$-calculus) and tactics for proof and
program development to a Haskell application programmer, via a stable,
well-documented and lightweight (as far as possible) API. The goal is
to allow: i) easy embedding of theorem proving tools in a Haskell
application; and ii) easy extension of the theorem prover with
\remph{domain specific} tactics, via an embedded domain specific
language (EDSL) for tactic construction.

%% \Coq{}
%% provides an extraction mechanism~\cite{extraction-coq} which generates
%% ML or Haskell code from a proof term, but this does not allow the easy
%% \remph{construction} of proof terms by an external tool. It is also
%% extensible to some extent, for example using a domain specific
%% language for creating user tactics, but the result is difficult to
%% embed in an external program.

%More
%recently, dependent types have been incorporated into programming
%languages such as Cayenne~\cite{cayenne-icfp}, DML~\cite{xi-thesis} and
%\Epigram{}~\cite{view-left,epigram-afp}.


%% have been used for several
%% large practical applications, including correctness proofs for a
%% compiler~\cite{leroy-compiler} and a computer assisted proof of the
%% four colour theorem~\cite{four-colour}. 

\subsection{Motivating Examples}

Many situations can benefit from a dependently typed proof and
programming framework accessible as a library from a Haskell program.
For each of these, by using an implementation of a well understood
type theory, we can be confident that the underlying framework is
sound.
%% --- provided of course that the implementation itself is correct. 
%% Implementing
%% eliminates the need to prove that a language and proof system are consistent with
%% each other or that a special purpose proof framework is sound.

\begin{description}
\item[Programming Languages] 
Dependent type theory can be used as the internal representation for a
functional programming language. 
%The core language of the Glasgow
%Haskell Compiler is \SystemF{}~\cite{core} --- dependent type theory
%generalises this by allowing types to be parametrised over values.
One advantage of a pure functional language is that correctness
properties of programs in the language can be proven by equational
reasoning.  Some tools exist to assist with this,
e.g. Sparkle~\cite{sparkle} for the Clean language~\cite{clean}, or
Cover~\cite{cover} for translating Haskell into
\Agda{}~\cite{agda}. However a problem with such tools is that they
separate the language implementation from the theorem prover --- every
language feature must be translated into the theorem prover's
representation, and any time the language implementation is changed,
this translation must also be changed.
In section
\ref{example2}, we will see how \Ivor{} can be used to implement a
language with a built-in theorem prover, with a common representation
for both.

\item[Verified DSL Implementation]
We have previously used \Ivor{} to demonstrate the implementation of
a verified domain specific language~\cite{dtpmsp-gpce}. The idea is to
represent the abstract syntax tree of a DSL program as a dependent
type, and write an interpreter which guarantees that invariant
properties of the program are maintained. Using staging
annotations~\cite{multi-taha}, such an interpreter can be specialised
to a translator. We are continuing to explore these techniques in the
context of resource aware programming~\cite{dt-framework}.

\item[Formal Systems] 

A formal system can be modelled in dependent type theory, and
properties of the system and derivations within the system can be
proved. A simple example is propositional logic --- the connectives
$\land$, $\lor$ and $\to$ are represented as types, and a theorem
prover is used to prove logical formulae.  Having an implementation of
type theory and an interactive theorem prover accessible as an API
makes it easy to write tools for working in a formal system, whether
for educational or practical purposes.  In section \ref{example1}, I
will give details of an implementation of propositional logic.

\end{description}

In general, the library can be used wherever formally certified code
is needed --- evaluation of dependently typed \Ivor{} programs is
possible from Haskell programs and the results can be inspected easily.
Whatever the situation, domain specific tactics are often
required. For example, 
an implementation of a programming language with subtyping may require
a tactic for inserting coercions, or
a computer arithmetic system may require an
implementation of Pugh's Omega decision procedure~\cite{pugh-omega}.
\Ivor{}'s API is designed to make implementation of such tactics as
easy as possible.

%\subsection{Why Do We Need Another Theorem Prover?}

%Relationship to e.g. \Coq{}.
