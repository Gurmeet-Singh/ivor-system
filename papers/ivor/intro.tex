\section{Introduction}

%\Ivor{} is a tactic-based theorem proving engine with a Haskell
%API. Unlike other systems such as \Coq{}~\cite{coq-manual} and
%Agda~\cite{agda}, the tactic engine is primarily intended to be used
%by programs, rather than a human operator. 

Type theory based theorem provers such as
\Coq{}~\cite{coq-manual} and Agda~\cite{agda} have achieved widespread
use as tools for verification of functional programs
(e.g.~\cite{leroy-compiler}, more?), derivation of correct programs
for their specification (citations?) and formal proofs
of mathematical properties (e.g.~\cite{four-colour}).  
However, these tools are designed with a
human operator in mind; the interface is textual which makes it
difficult for an external program to interact with them. \Coq{}
provide an extraction mechanism~\cite{extraction-coq} which generates
ML or Haskell code from a proof term, but this does not allow the easy
\remph{construction} of proof terms by an external tool.

%More
%recently, dependent types have been incorporated into programming
%languages such as Cayenne~\cite{cayenne-icfp}, DML~\cite{xi-thesis} and
%\Epigram{}~\cite{view-left,epigram-afp}.

The \Ivor{} library is designed to provide an implementation of
dependent type theory and tactics for proof and program development to
a Haskell application programmer, via a stable and well-documented
API. The goal is to allow: i) easy embedding of theorem proving tools
in a Haskell application; and ii) easy extension of the theorem prover
with \remph{domain specific} tactics.

%% have been used for several
%% large practical applications, including correctness proofs for a
%% compiler~\cite{leroy-compiler} and a computer assisted proof of the
%% four colour theorem~\cite{four-colour}. 

\subsection{Motivating Examples}

There are several situations where a dependently typed proof framework
accessible as a library from Haskell programs could be useful. For
example:

\begin{description}
\item[Formal Systems] 
A formal system can be modelled in dependent type theory, and
properties of the system and derivations within the system can be
proved. A simple example is first order logic --- it is
straightforward to represent the connectives $\land$, $\lor$ and $\to$
in dependent type theory and use a theorem prover to prove logical
formulae.
Having an implementation of type theory and an interactive theorem
prover accessible as an API makes it easy to write tools for working
in a formal system, whether for educational or practical purposes.
In section \ref{example1}, I will give details of an implementation of
first order logic.

\item[Programming Languages] 
Dependent type theory can be used as the core representation for a
functional programming language. The core language of the Glasgow
Haskell Compiler is \SystemF{}~\cite{core} --- dependent type theory
generalises this by allowing types to be parametrised over values.  An
often claimed advantage of pure functional programming is that it is
easy to prove correctness properties [citations needed]. Some tools
exist to assist with this, e.g. Sparkle~\cite{sparkle} for Clean, or
Cover~\cite{cover} for translating Haskell into Agda~\cite{agda}. However a
problem with such tools is that they separate the language from the
theorem prover; by using a common core representation for both, we can
be more confident that proofs are correct and be confident that the
theorem prover supports the entire language.
In section \ref{example2}, we will see how \Ivor{} can be used to
implement a language with a built-in theorem prover.

\item[Verified DSL Implementation]
We have previously used \Ivor{} to demonstrate the implementation of
a verified domain specific language~\cite{dtpmsp-gpce}. The idea is to
represent the abstract syntax tree of a DSL program as a dependent
type, and write an interpreter which guarantees that invariant
properties of the program are maintained. Using staging
annotations~\cite{multi-taha}, such an interpreter can be specialised
to a translator. We are continuing to explore these techniques in the
context of resource aware programming~\cite{dt-framework}.

\end{description}

Whatever the situation, domain specific tactics are often
required. For example, 
an implementation of a programming language with subtyping may require
a tactic for inserting coercions, or
a computer arithmetic system may require an
implementation of Pugh's Omega decision procedure~\cite{pugh-omega}.
\Ivor{}'s API is designed to make implementation of such tactics as
easy as possible.

%\subsection{Why Do We Need Another Theorem Prover?}

%Relationship to e.g. \Coq{}.
