\section{Related Work}

The ability to extend a theorem prover with user defined tactics has
its roots in Robin Milner's LCF~\cite{lcf-milner}. This introduced the
programming language ML to allow users to write tactics; we follow the
LCF approach in exposing the tactic engine as an API. However, unlike
other systems, we have not treated the theorem prover as an end in
itself, but intend to expose the technology to any Haskell application
which may need it.  The implementation of \Ivor{} is based on the
presentation of \Oleg{} in Conor McBride's
thesis~\cite{mcbride-thesis}; this technology also forms the basis for
the implementation of \Epigram{}~\cite{view-left}. The core language
of \Epigram{}~\cite{epireloaded} is similar to $\source$, with
extensions for observational equality. \Ivor{} uses implementation
techniques for \cite{not-a-number} for dealing with variables and
renaming, using de Bruijn indices.

Other theorem provers such as \Coq{}~\cite{coq-manual},
Agda~\cite{agda} and Isabell~\cite{isabelle} have varying degrees of
extensibility.  \Ivor{}'s interface design largely follows that of
\Coq{}. \Coq{} includes a high level domain specific language for
combining tactics and creating new tactics, along the lines of the
tactic combinators presented in section \ref{combinators}. This
language is ideal for many purposes, such as our \hdecl{contradiction}
tactic, but more complex examples such as \hdecl{buildTerm} would
require extending \Coq{} itself.

Isabelle~\cite{isabelle} is a generic theorem prover, in that it
includes a large body of object logics and a meta-language for
defining new logics. It includes a typed, extensible tactic language,
and can be called from ML programs, but unlike \Ivor{} is not based on
a dependent type theory.

The implementation of \Funl{} allows a theorem prover to be attached
to the language in a straightforward way, using \Ivor{}'s tactics
directly. This would be a possible method of attaching a theorem
prover to a more full featured programming language such as the
Sparkle~\cite{sparkle} prover for Clean~\cite{clean}.

\section{Conclusions}

Didn't talk about primitive types, general recursion or all sorts of
other bits and pieces. See web site.

Easy to make tools with proof gadgets attached, or verified
implementations of programming languages.

\subsection{Further Work}

Development driven by our research into Hume and dependent types.
We'll need some more tactics, e.g. Elimination with a Motive
\cite{elim-motive}. Perhaps a compiler, and optimisations from
\cite{brady-thesis}. An implementation of
coinduction~\cite{coinductive} would be nice, currently it's faked by
recursive functions which don't reduce at the type level, but a proper
implementation, perhaps with a syntactic criterion for correctness
would be better.
