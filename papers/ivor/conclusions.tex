\section{Related Work}

\Coq{} \cite{coq-manual} and Agda \cite{agda} obviously. Inspired by
\cite{mcbride-thesis}, and using implementation techniques from
\cite{not-a-number}. \Epigram{}~\cite{view-left} built on
a similar idea of theorem provers being for machines to use as much as
humans. Probably good to mention \cite{epireloaded} too.

Isabelle~\cite{isabelle}, generic theorem prover, not based on
dependent types, but flexible in that it can accept a variety of
calculi.  Sparkle~\cite{sparkle} as a special purpose theorem prover
for Clean~\cite{clean}.

\section{Conclusions}

Didn't talk about primitive types, general recursion or all sorts of
other bits and pieces. See web site.

Easy to make tools with proof gadgets attached, or verified
implementations of programming languages.

\subsection{Further Work}

Development driven by our research into Hume and dependent types.
We'll need some more tactics, e.g. Elimination with a Motive
\cite{elim-motive}. Perhaps a compiler, and optimisations from
\cite{brady-thesis}. An implementation of
coinduction~\cite{coinductive} would be nice, currently it's faked by
recursive functions which don't reduce at the type level, but a proper
implementation, perhaps with a syntactic criterion for correctness
would be better.
